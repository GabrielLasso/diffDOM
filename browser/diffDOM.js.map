{"version":3,"file":"diffDOM.js","sources":["../src/diffDOM/dom/fromVirtual.ts","../src/diffDOM/dom/apply.ts","../src/diffDOM/dom/undo.ts","../src/diffDOM/virtual/helpers.ts","../src/diffDOM/helpers.ts","../src/diffDOM/virtual/apply.ts","../src/diffDOM/virtual/fromDOM.ts","../src/diffDOM/virtual/fromString.ts","../src/diffDOM/virtual/diff.ts","../src/diffDOM/index.ts","../src/TraceLogger.ts"],"sourcesContent":["import { DiffDOMOptions, elementNodeType, textNodeType } from \"../types\"\n\nexport function objToNode(\n    objNode: elementNodeType,\n    insideSvg: boolean,\n    options: DiffDOMOptions\n) {\n    let node: Element | Text | Comment\n    if (objNode.nodeName === \"#text\") {\n        node = options.document.createTextNode((objNode as textNodeType).data)\n    } else if (objNode.nodeName === \"#comment\") {\n        node = options.document.createComment((objNode as textNodeType).data)\n    } else {\n        if (insideSvg) {\n            node = options.document.createElementNS(\n                \"http://www.w3.org/2000/svg\",\n                objNode.nodeName\n            )\n        } else if (objNode.nodeName.toLowerCase() === \"svg\") {\n            node = options.document.createElementNS(\n                \"http://www.w3.org/2000/svg\",\n                \"svg\"\n            )\n            insideSvg = true\n        } else {\n            node = options.document.createElement(objNode.nodeName)\n        }\n        if (objNode.attributes) {\n            Object.entries(objNode.attributes).forEach(([key, value]) =>\n                (node as Element).setAttribute(key, value)\n            )\n        }\n        if (objNode.childNodes) {\n            node = node as Element\n            objNode.childNodes.forEach(\n                (childNode: elementNodeType | textNodeType) =>\n                    node.appendChild(objToNode(childNode, insideSvg, options))\n            )\n        }\n        if (options.valueDiffing) {\n            if (\n                objNode.value &&\n                (node instanceof HTMLButtonElement ||\n                    node instanceof HTMLDataElement ||\n                    node instanceof HTMLInputElement ||\n                    node instanceof HTMLLIElement ||\n                    node instanceof HTMLMeterElement ||\n                    node instanceof HTMLOptionElement ||\n                    node instanceof HTMLProgressElement ||\n                    node instanceof HTMLParamElement)\n            ) {\n                node.value = objNode.value\n            }\n            if (objNode.checked && node instanceof HTMLInputElement) {\n                node.checked = objNode.checked\n            }\n            if (objNode.selected && node instanceof HTMLOptionElement) {\n                node.selected = objNode.selected\n            }\n        }\n    }\n    return node\n}\n","import { DiffDOMOptions, diffType, nodeType } from \"../types\"\nimport { Diff } from \"../helpers\"\n\nimport { objToNode } from \"./fromVirtual\"\n\n// ===== Apply a diff =====\n\nconst getFromRoute = (\n    node: Element,\n    route: number[]\n): Element | Text | false => {\n    route = route.slice()\n    while (route.length > 0) {\n        const c = route.splice(0, 1)[0]\n        node = node.childNodes[c] as Element\n    }\n    return node\n}\n\nexport function applyDiff(\n    tree: Element,\n    diff: diffType,\n    options: DiffDOMOptions // {preDiffApply, postDiffApply, textDiff, valueDiffing, _const}\n) {\n    const action = diff[options._const.action] as string | number\n    const route = diff[options._const.route] as number[]\n    let node\n\n    if (\n        ![options._const.addElement, options._const.addTextElement].includes(\n            action\n        )\n    ) {\n        // For adding nodes, we calculate the route later on. It's different because it includes the position of the newly added item.\n        node = getFromRoute(tree, route)\n    }\n\n    let newNode\n    let reference: Element\n    let nodeArray\n\n    // pre-diff hook\n    const info = {\n        diff,\n        node,\n    }\n\n    if (options.preDiffApply(info)) {\n        return true\n    }\n\n    switch (action) {\n        case options._const.addAttribute:\n            if (!node || !(node instanceof Element)) {\n                return false\n            }\n            node.setAttribute(\n                diff[options._const.name] as string,\n                diff[options._const.value] as string\n            )\n            break\n        case options._const.modifyAttribute:\n            if (!node || !(node instanceof Element)) {\n                return false\n            }\n            node.setAttribute(\n                diff[options._const.name] as string,\n                diff[options._const.newValue] as string\n            )\n            if (\n                node instanceof HTMLInputElement &&\n                diff[options._const.name] === \"value\"\n            ) {\n                node.value = diff[options._const.newValue] as string\n            }\n            break\n        case options._const.removeAttribute:\n            if (!node || !(node instanceof Element)) {\n                return false\n            }\n            node.removeAttribute(diff[options._const.name] as string)\n            break\n        case options._const.modifyTextElement:\n            if (!node || !(node instanceof Text)) {\n                return false\n            }\n            options.textDiff(\n                node,\n                node.data,\n                diff[options._const.oldValue] as string,\n                diff[options._const.newValue] as string\n            )\n            if (node.parentNode instanceof HTMLTextAreaElement) {\n                node.parentNode.value = diff[options._const.newValue] as string\n            }\n            break\n        case options._const.modifyValue:\n            if (!node || typeof node.value === \"undefined\") {\n                return false\n            }\n            node.value = diff[options._const.newValue]\n            break\n        case options._const.modifyComment:\n            if (!node || !(node instanceof Comment)) {\n                return false\n            }\n            options.textDiff(\n                node,\n                node.data,\n                diff[options._const.oldValue] as string,\n                diff[options._const.newValue] as string\n            )\n            break\n        case options._const.modifyChecked:\n            if (!node || typeof node.checked === \"undefined\") {\n                return false\n            }\n            node.checked = diff[options._const.newValue]\n            break\n        case options._const.modifySelected:\n            if (!node || typeof node.selected === \"undefined\") {\n                return false\n            }\n            node.selected = diff[options._const.newValue]\n            break\n        case options._const.replaceElement: {\n            const insideSvg =\n                (\n                    diff[options._const.newValue] as nodeType\n                ).nodeName.toLowerCase() === \"svg\" ||\n                node.parentNode.namespaceURI === \"http://www.w3.org/2000/svg\"\n            node.parentNode.replaceChild(\n                objToNode(\n                    diff[options._const.newValue] as nodeType,\n                    insideSvg,\n                    options\n                ),\n                node\n            )\n            break\n        }\n        case options._const.relocateGroup:\n            nodeArray = Array(\n                ...new Array(diff[options._const.groupLength])\n            ).map(() =>\n                node.removeChild(\n                    node.childNodes[diff[options._const.from] as number]\n                )\n            )\n            nodeArray.forEach((childNode, index) => {\n                if (index === 0) {\n                    reference =\n                        node.childNodes[diff[options._const.to] as number]\n                }\n                node.insertBefore(childNode, reference || null)\n            })\n            break\n        case options._const.removeElement:\n            node.parentNode.removeChild(node)\n            break\n        case options._const.addElement: {\n            const parentRoute = route.slice()\n            const c: number = parentRoute.splice(parentRoute.length - 1, 1)[0]\n            node = getFromRoute(tree, parentRoute)\n            if (!(node instanceof Element)) {\n                return false\n            }\n            node.insertBefore(\n                objToNode(\n                    diff[options._const.element] as nodeType,\n                    node.namespaceURI === \"http://www.w3.org/2000/svg\",\n                    options\n                ),\n                node.childNodes[c] || null\n            )\n            break\n        }\n        case options._const.removeTextElement: {\n            if (!node || node.nodeType !== 3) {\n                return false\n            }\n            const parentNode = node.parentNode\n            parentNode.removeChild(node)\n            if (parentNode instanceof HTMLTextAreaElement) {\n                parentNode.value = \"\"\n            }\n            break\n        }\n        case options._const.addTextElement: {\n            const parentRoute = route.slice()\n            const c: number = parentRoute.splice(parentRoute.length - 1, 1)[0]\n            newNode = options.document.createTextNode(\n                diff[options._const.value] as string\n            )\n            node = getFromRoute(tree, parentRoute)\n            if (!node.childNodes) {\n                return false\n            }\n            node.insertBefore(newNode, node.childNodes[c] || null)\n            if (node.parentNode instanceof HTMLTextAreaElement) {\n                node.parentNode.value = diff[options._const.value] as string\n            }\n            break\n        }\n        default:\n            console.log(\"unknown action\")\n    }\n\n    // if a new node was created, we might be interested in its\n    // post diff hook\n    options.postDiffApply({\n        diff: info.diff,\n        node: info.node,\n        newNode,\n    })\n\n    return true\n}\n\nexport function applyDOM(\n    tree: Element,\n    diffs: (Diff | diffType)[],\n    options: DiffDOMOptions\n) {\n    return diffs.every((diff: Diff | diffType) =>\n        applyDiff(tree, diff as diffType, options)\n    )\n}\n","import { DiffDOMOptions, diffType } from \"../types\"\nimport { Diff } from \"../helpers\"\nimport { applyDiff } from \"./apply\"\n\n// ===== Undo a diff =====\n\nfunction swap(obj: object, p1: string | number, p2: string | number) {\n    const tmp = obj[p1]\n    obj[p1] = obj[p2]\n    obj[p2] = tmp\n}\n\nfunction undoDiff(\n    tree: Element,\n    diff: diffType,\n    options: DiffDOMOptions // {preDiffApply, postDiffApply, textDiff, valueDiffing, _const}\n) {\n    switch (diff[options._const.action]) {\n        case options._const.addAttribute:\n            diff[options._const.action] = options._const.removeAttribute\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyAttribute:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.removeAttribute:\n            diff[options._const.action] = options._const.addAttribute\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyTextElement:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyValue:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyComment:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyChecked:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifySelected:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.replaceElement:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.relocateGroup:\n            swap(diff, options._const.from, options._const.to)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.removeElement:\n            diff[options._const.action] = options._const.addElement\n            applyDiff(tree, diff, options)\n            break\n        case options._const.addElement:\n            diff[options._const.action] = options._const.removeElement\n            applyDiff(tree, diff, options)\n            break\n        case options._const.removeTextElement:\n            diff[options._const.action] = options._const.addTextElement\n            applyDiff(tree, diff, options)\n            break\n        case options._const.addTextElement:\n            diff[options._const.action] = options._const.removeTextElement\n            applyDiff(tree, diff, options)\n            break\n        default:\n            console.log(\"unknown action\")\n    }\n}\n\nexport function undoDOM(\n    tree: Element,\n    diffs: (diffType | Diff)[],\n    options: DiffDOMOptions\n) {\n    diffs = diffs.slice()\n    diffs.reverse()\n    diffs.forEach((diff: diffType | Diff) => {\n        undoDiff(tree, diff as diffType, options)\n    })\n}\n","import {\n    diffNodeType,\n    elementDiffNodeType,\n    elementNodeType,\n    nodeType,\n    subsetType,\n    textDiffNodeType,\n    textNodeType,\n} from \"../types\"\nimport { Diff } from \"../helpers\"\nconst elementDescriptors = (el: diffNodeType) => {\n    const output = []\n    output.push(el.nodeName)\n    if (el.nodeName !== \"#text\" && el.nodeName !== \"#comment\") {\n        el = el as elementDiffNodeType\n        if (el.attributes) {\n            if (el.attributes[\"class\"]) {\n                output.push(\n                    `${el.nodeName}.${el.attributes[\"class\"].replace(\n                        / /g,\n                        \".\"\n                    )}`\n                )\n            }\n            if (el.attributes.id) {\n                output.push(`${el.nodeName}#${el.attributes.id}`)\n            }\n        }\n    }\n    return output\n}\n\nconst findUniqueDescriptors = (li: diffNodeType[]) => {\n    const uniqueDescriptors = {}\n    const duplicateDescriptors = {}\n\n    li.forEach((node: nodeType) => {\n        elementDescriptors(node).forEach((descriptor) => {\n            const inUnique = descriptor in uniqueDescriptors\n            const inDupes = descriptor in duplicateDescriptors\n            if (!inUnique && !inDupes) {\n                uniqueDescriptors[descriptor] = true\n            } else if (inUnique) {\n                delete uniqueDescriptors[descriptor]\n                duplicateDescriptors[descriptor] = true\n            }\n        })\n    })\n\n    return uniqueDescriptors\n}\n\nexport const uniqueInBoth = (l1: diffNodeType[], l2: diffNodeType[]) => {\n    const l1Unique = findUniqueDescriptors(l1)\n    const l2Unique = findUniqueDescriptors(l2)\n    const inBoth = {}\n\n    Object.keys(l1Unique).forEach((key) => {\n        if (l2Unique[key]) {\n            inBoth[key] = true\n        }\n    })\n\n    return inBoth\n}\n\nexport const removeDone = (tree: elementDiffNodeType) => {\n    delete tree.outerDone\n    delete tree.innerDone\n    delete tree.valueDone\n    if (tree.childNodes) {\n        return tree.childNodes.every(removeDone)\n    } else {\n        return true\n    }\n}\n\nexport const cleanNode = (diffNode: diffNodeType) => {\n    if (Object.prototype.hasOwnProperty.call(diffNode, \"data\")) {\n        const textNode: textNodeType = {\n            nodeName: diffNode.nodeName === \"#text\" ? \"#text\" : \"#comment\",\n            data: (diffNode as textDiffNodeType).data,\n        }\n        return textNode\n    } else {\n        const elementNode: elementNodeType = {\n            nodeName: diffNode.nodeName,\n        }\n        diffNode = diffNode as elementDiffNodeType\n        if (Object.prototype.hasOwnProperty.call(diffNode, \"attributes\")) {\n            elementNode.attributes = diffNode.attributes\n        }\n        if (Object.prototype.hasOwnProperty.call(diffNode, \"checked\")) {\n            elementNode.checked = diffNode.checked\n        }\n        if (Object.prototype.hasOwnProperty.call(diffNode, \"value\")) {\n            elementNode.value = diffNode.value\n        }\n        if (Object.prototype.hasOwnProperty.call(diffNode, \"selected\")) {\n            elementNode.selected = diffNode.selected\n        }\n        if (Object.prototype.hasOwnProperty.call(diffNode, \"childNodes\")) {\n            elementNode.childNodes = diffNode.childNodes.map((diffChildNode) =>\n                cleanNode(diffChildNode)\n            )\n        }\n        return elementNode\n    }\n}\n\nexport const isEqual = (e1: diffNodeType, e2: diffNodeType) => {\n    if (\n        ![\"nodeName\", \"value\", \"checked\", \"selected\", \"data\"].every(\n            (element) => {\n                if (e1[element] !== e2[element]) {\n                    return false\n                }\n                return true\n            }\n        )\n    ) {\n        return false\n    }\n    if (Object.prototype.hasOwnProperty.call(e1, \"data\")) {\n        // Comment or Text\n        return true\n    }\n    e1 = e1 as elementDiffNodeType\n    e2 = e2 as elementDiffNodeType\n    if (Boolean(e1.attributes) !== Boolean(e2.attributes)) {\n        return false\n    }\n\n    if (Boolean(e1.childNodes) !== Boolean(e2.childNodes)) {\n        return false\n    }\n    if (e1.attributes) {\n        const e1Attributes = Object.keys(e1.attributes)\n        const e2Attributes = Object.keys(e2.attributes)\n\n        if (e1Attributes.length !== e2Attributes.length) {\n            return false\n        }\n        if (\n            !e1Attributes.every((attribute) => {\n                if (\n                    (e1 as elementDiffNodeType).attributes[attribute] !==\n                    (e2 as elementDiffNodeType).attributes[attribute]\n                ) {\n                    return false\n                }\n                return true\n            })\n        ) {\n            return false\n        }\n    }\n    if (e1.childNodes) {\n        if (e1.childNodes.length !== e2.childNodes.length) {\n            return false\n        }\n        if (\n            !e1.childNodes.every((childNode: nodeType, index: number) =>\n                isEqual(childNode, e2.childNodes[index])\n            )\n        ) {\n            return false\n        }\n    }\n\n    return true\n}\n\nexport const roughlyEqual = (\n    e1: diffNodeType,\n    e2: diffNodeType,\n    uniqueDescriptors: { [key: string]: boolean },\n    sameSiblings: boolean,\n    preventRecursion = false\n) => {\n    if (!e1 || !e2) {\n        return 0\n    }\n\n    if (e1.nodeName !== e2.nodeName) {\n        return 0\n    }\n\n    if ([\"#text\", \"#comment\"].includes(e1.nodeName)) {\n        // Note that we initially don't care what the text content of a node is,\n        // the mere fact that it's the same tag and \"has text\" means it's roughly\n        // equal, and then we can find out the true text difference later.\n        return preventRecursion\n            ? 1\n            : (e1 as textDiffNodeType).data === (e2 as textDiffNodeType).data ? 1 : 0\n    }\n\n    e1 = e1 as elementDiffNodeType\n    e2 = e2 as elementDiffNodeType\n\n    if (e1.nodeName in uniqueDescriptors) {\n        return 1\n    }\n\n    let similarity = 1\n\n    if (e1.attributes && e2.attributes) {\n        if (e1.attributes.id) {\n            if (e1.attributes.id !== e2.attributes.id) {\n                similarity *= 0.5\n            } else {\n                const idDescriptor = `${e1.nodeName}#${e1.attributes.id}`\n                if (idDescriptor in uniqueDescriptors) {\n                    return 1\n                }\n            }\n        }\n        if (\n            e1.attributes[\"class\"]\n        ) {\n            if (e1.attributes[\"class\"] !== e2.attributes[\"class\"]) {\n                similarity *= 0.7\n            } else {\n                const classDescriptor = `${e1.nodeName}.${e1.attributes[\n                    \"class\"\n                ].replace(/ /g, \".\")}`\n                if (classDescriptor in uniqueDescriptors) {\n                    return 1\n                }\n            }\n        }\n    }\n\n    if (!sameSiblings) {\n        similarity *= 0.6\n    }\n\n    const nodeList1 = e1.childNodes ? e1.childNodes.slice().reverse() : []\n    const nodeList2 = e2.childNodes ? e2.childNodes.slice().reverse() : []\n\n    if (nodeList1.length !== nodeList2.length) {\n        similarity = 0\n    } else {\n        if (preventRecursion) {\n            if (!nodeList1.every(\n                (element: nodeType, index: number) => element.nodeName === nodeList2[index].nodeName\n            )) {\n                similarity *= 0.8\n            }\n        } else {\n            // note: we only allow one level of recursion at any depth. If 'preventRecursion'\n            // was not set, we must explicitly force it to true for child iterations.\n            const childUniqueDescriptors = uniqueInBoth(nodeList1, nodeList2)\n            if (nodeList1.length) {\n                similarity *= (nodeList1.map((element: nodeType, index: number) =>\n                        roughlyEqual(\n                            element,\n                            nodeList2[index],\n                            childUniqueDescriptors,\n                            true,\n                            true\n                        ),\n                    ).reduce((a, b) => a + b, 0) / nodeList1.length)\n            }\n\n        }\n    }\n    return Math.max(Math.min(similarity, 1), 0)\n\n}\n\n/**\n * based on https://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Longest_common_substring#JavaScript\n */\nconst findCommonSubsets = (\n    c1: diffNodeType[],\n    c2: diffNodeType[],\n    marked1: boolean[],\n    marked2: boolean[]\n) => {\n    let lcsSize = 0\n    let lcsSimilarity = 0\n    let index: number[] = []\n    const c1Length = c1.length\n    const c2Length = c2.length\n\n    const // set up the matching table\n        matches = Array(...new Array(c1Length + 1)).map(() => [])\n\n    const uniqueDescriptors = uniqueInBoth(c1, c2)\n\n    let // If all of the elements are the same tag, id and class, then we can\n        // consider them roughly the same even if they have a different number of\n        // children. This will reduce removing and re-adding similar elements.\n        subsetsSame = c1Length === c2Length\n\n    if (subsetsSame) {\n        c1.some((element: nodeType, i: number) => {\n            const c1Desc = elementDescriptors(element)\n            const c2Desc = elementDescriptors(c2[i])\n            if (c1Desc.length !== c2Desc.length) {\n                subsetsSame = false\n                return true\n            }\n            c1Desc.some((description, i) => {\n                if (description !== c2Desc[i]) {\n                    subsetsSame = false\n                    return true\n                }\n            })\n            if (!subsetsSame) {\n                return true\n            }\n        })\n    }\n\n    // fill the matches with distance values\n    for (let c1Index = 0; c1Index < c1Length; c1Index++) {\n        const c1Element = c1[c1Index]\n        for (let c2Index = 0; c2Index < c2Length; c2Index++) {\n            const c2Element = c2[c2Index]\n            //console.log({c1Element, c2Element})\n            const elementSimilarity = roughlyEqual(\n                c1Element,\n                c2Element,\n                uniqueDescriptors,\n                subsetsSame\n            )\n            if (\n                !marked1[c1Index] &&\n                !marked2[c2Index] &&\n                elementSimilarity\n            ) {\n            //    console.log('yes')\n                matches[c1Index + 1][c2Index + 1] = matches[c1Index][c2Index]\n                    ? matches[c1Index][c2Index] + 1\n                    : 1\n                console.log([c1Index, c2Index, matches[c1Index + 1][c2Index + 1], lcsSize, elementSimilarity, lcsSimilarity])\n                if (matches[c1Index + 1][c2Index + 1] > lcsSize) {\n                    lcsSize = matches[c1Index + 1][c2Index + 1]\n                    lcsSimilarity = elementSimilarity\n                    index = [c1Index + 1, c2Index + 1]\n                } else if (matches[c1Index + 1][c2Index + 1] === lcsSize && elementSimilarity > lcsSimilarity) {\n                    lcsSize = matches[c1Index + 1][c2Index + 1]\n                    lcsSimilarity = elementSimilarity\n                    index = [c1Index + 1, c2Index + 1]\n                }\n            } else {\n                matches[c1Index + 1][c2Index + 1] = 0\n            }\n        }\n    }\n\n    if (lcsSize === 0) {\n        return false\n    }\n    console.log({\n        oldValue: index[0] - lcsSize,\n        newValue: index[1] - lcsSize,\n        length: lcsSize,\n    })\n    return {\n        oldValue: index[0] - lcsSize,\n        newValue: index[1] - lcsSize,\n        length: lcsSize,\n    }\n}\n\nconst makeBooleanArray = (n: number, v: boolean) =>\n    Array(...new Array(n)).map(() => v)\n\n/**\n * Generate arrays that indicate which node belongs to which subset,\n * or whether it's actually an orphan node, existing in only one\n * of the two trees, rather than somewhere in both.\n *\n * So if t1 = <img><canvas><br>, t2 = <canvas><br><img>.\n * The longest subset is \"<canvas><br>\" (length 2), so it will group 0.\n * The second longest is \"<img>\" (length 1), so it will be group 1.\n * gaps1 will therefore be [1,0,0] and gaps2 [0,0,1].\n *\n * If an element is not part of any group, it will stay being 'true', which\n * is the initial value. For example:\n * t1 = <img><p></p><br><canvas>, t2 = <b></b><br><canvas><img>\n *\n * The \"<p></p>\" and \"<b></b>\" do only show up in one of the two and will\n * therefore be marked by \"true\". The remaining parts are parts of the\n * groups 0 and 1:\n * gaps1 = [1, true, 0, 0], gaps2 = [true, 0, 0, 1]\n *\n */\nexport const getGapInformation = (\n    t1: elementDiffNodeType,\n    t2: elementDiffNodeType,\n    stable: subsetType[]\n) => {\n    const gaps1: (true | number)[] = t1.childNodes\n        ? (makeBooleanArray(t1.childNodes.length, true) as true[])\n        : []\n    const gaps2: (true | number)[] = t2.childNodes\n        ? (makeBooleanArray(t2.childNodes.length, true) as true[])\n        : []\n    let group = 0\n\n    // give elements from the same subset the same group number\n    stable.forEach((subset: subsetType) => {\n        const endOld = subset.oldValue + subset.length\n        const endNew = subset.newValue + subset.length\n\n        for (let j = subset.oldValue; j < endOld; j += 1) {\n            gaps1[j] = group\n        }\n        for (let j = subset.newValue; j < endNew; j += 1) {\n            gaps2[j] = group\n        }\n        group += 1\n    })\n\n    return {\n        gaps1,\n        gaps2,\n    }\n}\n\n/**\n * Find all matching subsets, based on immediate child differences only.\n */\nconst markBoth = (marked1, marked2, subset: subsetType, i: number) => {\n    marked1[subset.oldValue + i] = true\n    marked2[subset.newValue + i] = true\n}\n\nexport const markSubTrees = (\n    oldTree: elementDiffNodeType,\n    newTree: elementDiffNodeType\n) => {\n    // note: the child lists are views, and so update as we update old/newTree\n    const oldChildren = oldTree.childNodes ? oldTree.childNodes : []\n\n    const newChildren = newTree.childNodes ? newTree.childNodes : []\n    const marked1 = makeBooleanArray(oldChildren.length, false)\n    const marked2 = makeBooleanArray(newChildren.length, false)\n    const subsets = []\n\n    // console.log({\n    //     oldChildren: JSON.parse(JSON.stringify(oldChildren)),\n    //     newChildren: JSON.parse(JSON.stringify(newChildren)),\n    //     marked1: JSON.parse(JSON.stringify(marked1)),\n    //     marked2: JSON.parse(JSON.stringify(marked2)),\n    // })\n\n    const returnIndex = function () {\n        return arguments[1]\n    }\n\n    let foundAllSubsets = false\n\n    while (!foundAllSubsets) {\n        const subset = findCommonSubsets(\n            oldChildren,\n            newChildren,\n            marked1,\n            marked2\n        )\n        //console.log({subset: JSON.parse(JSON.stringify(subset))})\n        if (subset) {\n            subsets.push(subset)\n            const subsetArray = Array(...new Array(subset.length)).map(\n                returnIndex\n            )\n            subsetArray.forEach((item) =>\n                markBoth(marked1, marked2, subset, item)\n            )\n        } else {\n            foundAllSubsets = true\n        }\n    }\n\n    oldTree.subsets = subsets\n    oldTree.subsetsAge = 100\n    return subsets\n}\n\nexport class DiffTracker {\n    list: Diff[]\n    constructor() {\n        this.list = []\n    }\n\n    add(diffs: Diff[]) {\n        this.list.push(...diffs)\n    }\n    forEach(fn: (Diff) => void) {\n        this.list.forEach((li: Diff) => fn(li))\n    }\n}\n\n//export const elementHasValue = (element: Element) : boolean => element instanceof HTMLButtonElement || element instanceof HTMLDataElement || element instanceof HTMLInputElement || element instanceof HTMLLIElement || element instanceof HTMLMeterElement || element instanceof HTMLOptionElement || element instanceof HTMLProgressElement || element instanceof HTMLParamElement\n","import { elementNodeType } from \"./types\"\n\nexport class Diff {\n    constructor(options = {}) {\n        Object.entries(options).forEach(([key, value]) => (this[key] = value))\n    }\n\n    toString() {\n        return JSON.stringify(this)\n    }\n\n    setValue(\n        aKey: string | number,\n        aValue:\n            | string\n            | number\n            | boolean\n            | number[]\n            | { [key: string]: string | { [key: string]: string } }\n            | elementNodeType\n    ) {\n        this[aKey] = aValue\n        return this\n    }\n}\n","import { DiffDOMOptions, elementNodeType, nodeType, subsetType } from \"../types\"\nimport { Diff } from \"../helpers\"\n// ===== Apply a virtual diff =====\n\nfunction getFromVirtualRoute(tree: elementNodeType, route: number[]) {\n    let node = tree\n    let parentNode\n    let nodeIndex\n\n    route = route.slice()\n    while (route.length > 0) {\n        nodeIndex = route.splice(0, 1)[0]\n        parentNode = node\n        node = node.childNodes ? node.childNodes[nodeIndex] : undefined\n    }\n    return {\n        node,\n        parentNode,\n        nodeIndex,\n    }\n}\n\nfunction applyVirtualDiff(\n    tree: elementNodeType,\n    diff: Diff,\n    options: DiffDOMOptions // {preVirtualDiffApply, postVirtualDiffApply, _const}\n) {\n    let node, parentNode, nodeIndex\n\n    if (\n        ![options._const.addElement, options._const.addTextElement].includes(\n            diff[options._const.action]\n        )\n    ) {\n        // For adding nodes, we calculate the route later on. It's different because it includes the position of the newly added item.\n        const routeInfo = getFromVirtualRoute(tree, diff[options._const.route])\n        node = routeInfo.node\n        parentNode = routeInfo.parentNode\n        nodeIndex = routeInfo.nodeIndex\n    }\n\n    const newSubsets: subsetType[] = []\n\n    // pre-diff hook\n    const info = {\n        diff,\n        node,\n    }\n\n    if (options.preVirtualDiffApply(info)) {\n        return true\n    }\n\n    let newNode\n    let nodeArray\n    let route\n\n    switch (diff[options._const.action]) {\n        case options._const.addAttribute:\n            if (!node.attributes) {\n                node.attributes = {}\n            }\n\n            node.attributes[diff[options._const.name]] =\n                diff[options._const.value]\n\n            if (diff[options._const.name] === \"checked\") {\n                node.checked = true\n            } else if (diff[options._const.name] === \"selected\") {\n                node.selected = true\n            } else if (\n                node.nodeName === \"INPUT\" &&\n                diff[options._const.name] === \"value\"\n            ) {\n                node.value = diff[options._const.value]\n            }\n\n            break\n        case options._const.modifyAttribute:\n            node.attributes[diff[options._const.name]] =\n                diff[options._const.newValue]\n            break\n        case options._const.removeAttribute:\n            delete node.attributes[diff[options._const.name]]\n\n            if (Object.keys(node.attributes).length === 0) {\n                delete node.attributes\n            }\n\n            if (diff[options._const.name] === \"checked\") {\n                node.checked = false\n            } else if (diff[options._const.name] === \"selected\") {\n                delete node.selected\n            } else if (\n                node.nodeName === \"INPUT\" &&\n                diff[options._const.name] === \"value\"\n            ) {\n                delete node.value\n            }\n\n            break\n        case options._const.modifyTextElement:\n            node.data = diff[options._const.newValue]\n            if (parentNode.nodeName === \"TEXTAREA\") {\n                parentNode.value = diff[options._const.newValue]\n            }\n            break\n        case options._const.modifyValue:\n            node.value = diff[options._const.newValue]\n            break\n        case options._const.modifyComment:\n            node.data = diff[options._const.newValue]\n            break\n        case options._const.modifyChecked:\n            node.checked = diff[options._const.newValue]\n            break\n        case options._const.modifySelected:\n            node.selected = diff[options._const.newValue]\n            break\n        case options._const.replaceElement:\n            newNode = diff[options._const.newValue]\n            parentNode.childNodes[nodeIndex] = newNode\n            break\n        case options._const.relocateGroup:\n            nodeArray = node.childNodes\n                .splice(\n                    diff[options._const.from],\n                    diff[options._const.groupLength]\n                )\n                .reverse()\n            nodeArray.forEach((movedNode: nodeType) =>\n                node.childNodes.splice(diff[options._const.to], 0, movedNode)\n            )\n            if (node.subsets) {\n                node.subsets.forEach((map: subsetType) => {\n                    if (\n                        diff[options._const.from] < diff[options._const.to] &&\n                        map.oldValue <= diff[options._const.to] &&\n                        map.oldValue > diff[options._const.from]\n                    ) {\n                        map.oldValue -= diff[options._const.groupLength]\n                        const splitLength =\n                            map.oldValue + map.length - diff[options._const.to]\n                        if (splitLength > 0) {\n                            // new insertion splits map.\n                            newSubsets.push({\n                                oldValue:\n                                    diff[options._const.to] +\n                                    diff[options._const.groupLength],\n                                newValue:\n                                    map.newValue + map.length - splitLength,\n                                length: splitLength,\n                            })\n                            map.length -= splitLength\n                        }\n                    } else if (\n                        diff[options._const.from] > diff[options._const.to] &&\n                        map.oldValue > diff[options._const.to] &&\n                        map.oldValue < diff[options._const.from]\n                    ) {\n                        map.oldValue += diff[options._const.groupLength]\n                        const splitLength =\n                            map.oldValue + map.length - diff[options._const.to]\n                        if (splitLength > 0) {\n                            // new insertion splits map.\n                            newSubsets.push({\n                                oldValue:\n                                    diff[options._const.to] +\n                                    diff[options._const.groupLength],\n                                newValue:\n                                    map.newValue + map.length - splitLength,\n                                length: splitLength,\n                            })\n                            map.length -= splitLength\n                        }\n                    } else if (map.oldValue === diff[options._const.from]) {\n                        map.oldValue = diff[options._const.to]\n                    }\n                })\n            }\n\n            break\n        case options._const.removeElement:\n            parentNode.childNodes.splice(nodeIndex, 1)\n            if (parentNode.subsets) {\n                parentNode.subsets.forEach((map: subsetType) => {\n                    if (map.oldValue > nodeIndex) {\n                        map.oldValue -= 1\n                    } else if (map.oldValue === nodeIndex) {\n                        map.delete = true\n                    } else if (\n                        map.oldValue < nodeIndex &&\n                        map.oldValue + map.length > nodeIndex\n                    ) {\n                        if (map.oldValue + map.length - 1 === nodeIndex) {\n                            map.length--\n                        } else {\n                            newSubsets.push({\n                                newValue:\n                                    map.newValue + nodeIndex - map.oldValue,\n                                oldValue: nodeIndex,\n                                length:\n                                    map.length - nodeIndex + map.oldValue - 1,\n                            })\n                            map.length = nodeIndex - map.oldValue\n                        }\n                    }\n                })\n            }\n            node = parentNode\n            break\n        case options._const.addElement: {\n            route = diff[options._const.route].slice()\n            const c: number = route.splice(route.length - 1, 1)[0]\n            node = getFromVirtualRoute(tree, route)?.node\n            newNode = diff[options._const.element]\n\n            if (!node.childNodes) {\n                node.childNodes = []\n            }\n\n            if (c >= node.childNodes.length) {\n                node.childNodes.push(newNode)\n            } else {\n                node.childNodes.splice(c, 0, newNode)\n            }\n            if (node.subsets) {\n                node.subsets.forEach((map: subsetType) => {\n                    if (map.oldValue >= c) {\n                        map.oldValue += 1\n                    } else if (\n                        map.oldValue < c &&\n                        map.oldValue + map.length > c\n                    ) {\n                        const splitLength = map.oldValue + map.length - c\n                        newSubsets.push({\n                            newValue: map.newValue + map.length - splitLength,\n                            oldValue: c + 1,\n                            length: splitLength,\n                        })\n                        map.length -= splitLength\n                    }\n                })\n            }\n            break\n        }\n        case options._const.removeTextElement:\n            parentNode.childNodes.splice(nodeIndex, 1)\n            if (parentNode.nodeName === \"TEXTAREA\") {\n                delete parentNode.value\n            }\n            if (parentNode.subsets) {\n                parentNode.subsets.forEach((map: subsetType) => {\n                    if (map.oldValue > nodeIndex) {\n                        map.oldValue -= 1\n                    } else if (map.oldValue === nodeIndex) {\n                        map.delete = true\n                    } else if (\n                        map.oldValue < nodeIndex &&\n                        map.oldValue + map.length > nodeIndex\n                    ) {\n                        if (map.oldValue + map.length - 1 === nodeIndex) {\n                            map.length--\n                        } else {\n                            newSubsets.push({\n                                newValue:\n                                    map.newValue + nodeIndex - map.oldValue,\n                                oldValue: nodeIndex,\n                                length:\n                                    map.length - nodeIndex + map.oldValue - 1,\n                            })\n                            map.length = nodeIndex - map.oldValue\n                        }\n                    }\n                })\n            }\n            node = parentNode\n            break\n        case options._const.addTextElement: {\n            route = diff[options._const.route].slice()\n            const c: number = route.splice(route.length - 1, 1)[0]\n            newNode = {}\n            newNode.nodeName = \"#text\"\n            newNode.data = diff[options._const.value]\n            node = getFromVirtualRoute(tree, route).node\n            if (!node.childNodes) {\n                node.childNodes = []\n            }\n\n            if (c >= node.childNodes.length) {\n                node.childNodes.push(newNode)\n            } else {\n                node.childNodes.splice(c, 0, newNode)\n            }\n            if (node.nodeName === \"TEXTAREA\") {\n                node.value = diff[options._const.newValue]\n            }\n            if (node.subsets) {\n                node.subsets.forEach((map: subsetType) => {\n                    if (map.oldValue >= c) {\n                        map.oldValue += 1\n                    }\n                    if (map.oldValue < c && map.oldValue + map.length > c) {\n                        const splitLength = map.oldValue + map.length - c\n                        newSubsets.push({\n                            newValue: map.newValue + map.length - splitLength,\n                            oldValue: c + 1,\n                            length: splitLength,\n                        })\n                        map.length -= splitLength\n                    }\n                })\n            }\n            break\n        }\n        default:\n            console.log(\"unknown action\")\n    }\n\n    if (node.subsets) {\n        node.subsets = node.subsets.filter(\n            (map: subsetType) => !map.delete && map.oldValue !== map.newValue\n        )\n        if (newSubsets.length) {\n            node.subsets = node.subsets.concat(newSubsets)\n        }\n    }\n\n    options.postVirtualDiffApply({\n        node: info.node,\n        diff: info.diff,\n        newNode,\n    })\n\n    return\n}\n\nexport function applyVirtual(\n    tree: elementNodeType,\n    diffs: Diff[],\n    options: DiffDOMOptions\n) {\n    diffs.forEach((diff: Diff) => {\n        applyVirtualDiff(tree, diff, options)\n    })\n    return true\n}\n","import { DiffDOMOptionsPartial, elementNodeType, textNodeType } from \"../types\"\n\nexport function nodeToObj(\n    aNode: Element,\n    options: DiffDOMOptionsPartial = { valueDiffing: true }\n) {\n    const objNode: elementNodeType | textNodeType = {\n        nodeName: aNode.nodeName,\n    }\n    if (aNode instanceof Text || aNode instanceof Comment) {\n        ;(objNode as unknown as textNodeType).data = aNode.data\n    } else {\n        if (aNode.attributes && aNode.attributes.length > 0) {\n            objNode.attributes = {}\n            const nodeArray = Array.prototype.slice.call(aNode.attributes)\n            nodeArray.forEach(\n                (attribute) =>\n                    (objNode.attributes[attribute.name] = attribute.value)\n            )\n        }\n        if (aNode.childNodes && aNode.childNodes.length > 0) {\n            objNode.childNodes = []\n            const nodeArray = Array.prototype.slice.call(aNode.childNodes)\n            nodeArray.forEach((childNode) =>\n                objNode.childNodes.push(nodeToObj(childNode, options))\n            )\n        }\n        if (options.valueDiffing) {\n            if (aNode instanceof HTMLTextAreaElement) {\n                objNode.value = aNode.value\n            }\n            if (\n                aNode instanceof HTMLInputElement &&\n                [\"radio\", \"checkbox\"].includes(aNode.type.toLowerCase()) &&\n                aNode.checked !== undefined\n            ) {\n                objNode.checked = aNode.checked\n            } else if (\n                aNode instanceof HTMLButtonElement ||\n                aNode instanceof HTMLDataElement ||\n                aNode instanceof HTMLInputElement ||\n                aNode instanceof HTMLLIElement ||\n                aNode instanceof HTMLMeterElement ||\n                aNode instanceof HTMLOptionElement ||\n                aNode instanceof HTMLProgressElement ||\n                aNode instanceof HTMLParamElement\n            ) {\n                objNode.value = aNode.value\n            }\n            if (aNode instanceof HTMLOptionElement) {\n                objNode.selected = aNode.selected\n            }\n        }\n    }\n    return objNode\n}\n","import { DiffDOMOptionsPartial, nodeType } from \"../types\"\n\n// from html-parse-stringify (MIT)\n\nconst tagRE =\n    /<\\s*\\/*[a-zA-Z:_][a-zA-Z0-9:_\\-.]*\\s*(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\"/>])*\\/*\\s*>|<!--(?:.|\\n|\\r)*?-->/g\n\nconst attrRE = /\\s([^'\"/\\s><]+?)[\\s/>]|([^\\s=]+)=\\s?(\".*?\"|'.*?')/g\n\nfunction unescape(string: string) {\n    return string\n        .replace(/&lt;/g, \"<\")\n        .replace(/&gt;/g, \">\")\n        .replace(/&amp;/g, \"&\")\n}\n\n// create optimized lookup object for\n// void elements as listed here:\n// https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\nconst lookup = {\n    area: true,\n    base: true,\n    br: true,\n    col: true,\n    embed: true,\n    hr: true,\n    img: true,\n    input: true,\n    keygen: true,\n    link: true,\n    menuItem: true,\n    meta: true,\n    param: true,\n    source: true,\n    track: true,\n    wbr: true,\n}\n\nconst parseTag = (tag: string) => {\n    const res = {\n        nodeName: \"\",\n        attributes: {},\n    }\n    let voidElement = false\n    let type = \"tag\"\n\n    let tagMatch = tag.match(/<\\/?([^\\s]+?)[/\\s>]/)\n    if (tagMatch) {\n        res.nodeName = tagMatch[1].toUpperCase()\n        if (lookup[tagMatch[1]] || tag.charAt(tag.length - 2) === \"/\") {\n            voidElement = true\n        }\n\n        // handle comment tag\n        if (res.nodeName.startsWith(\"!--\")) {\n            const endIndex = tag.indexOf(\"-->\")\n            return {\n                type: \"comment\",\n                node: {\n                    nodeName: \"#comment\",\n                    data: endIndex !== -1 ? tag.slice(4, endIndex) : \"\",\n                },\n                voidElement,\n            }\n        }\n    }\n\n    let reg = new RegExp(attrRE)\n    let result = null\n    let done = false\n    while (!done) {\n        result = reg.exec(tag)\n\n        if (result === null) {\n            done = true\n        } else if (result[0].trim()) {\n            if (result[1]) {\n                let attr = result[1].trim()\n                let arr = [attr, \"\"]\n\n                if (attr.indexOf(\"=\") > -1) arr = attr.split(\"=\")\n                res.attributes[arr[0]] = arr[1]\n                reg.lastIndex--\n            } else if (result[2])\n                res.attributes[result[2]] = result[3]\n                    .trim()\n                    .substring(1, result[3].length - 1)\n        }\n    }\n\n    return {\n        type,\n        node: res,\n        voidElement,\n    }\n}\n\nexport const stringToObj = (\n    html: string,\n    options: DiffDOMOptionsPartial = { valueDiffing: true }\n) => {\n    const result: nodeType[] = []\n    let current: { type: string; node: nodeType; voidElement: boolean }\n    let level = -1\n    const arr: { type: string; node: nodeType; voidElement: boolean }[] = []\n    let inComponent = false\n\n    // handle text at top level\n    if (html.indexOf(\"<\") !== 0) {\n        const end = html.indexOf(\"<\")\n        result.push({\n            nodeName: \"#text\",\n            data: end === -1 ? html : html.substring(0, end),\n        })\n    }\n\n    html.replace(tagRE, (tag: string, index: number) => {\n        if (inComponent) {\n            if (tag !== `</${current.node.nodeName}>`) {\n                return \"\"\n            } else {\n                inComponent = false\n            }\n        }\n        const isOpen = tag.charAt(1) !== \"/\"\n        const isComment = tag.startsWith(\"<!--\")\n        const start = index + tag.length\n        const nextChar = html.charAt(start)\n\n        if (isComment) {\n            const comment = parseTag(tag).node\n\n            // if we're at root, push new base node\n            if (level < 0) {\n                result.push(comment)\n                return \"\"\n            }\n            const parent = arr[level]\n            if (parent && comment.nodeName) {\n                if (!parent.node.childNodes) {\n                    parent.node.childNodes = []\n                }\n                parent.node.childNodes.push(comment)\n            }\n            return \"\"\n        }\n\n        if (isOpen) {\n            current = parseTag(tag)\n            level++\n            if (\n                !current.voidElement &&\n                !inComponent &&\n                nextChar &&\n                nextChar !== \"<\"\n            ) {\n                if (!current.node.childNodes) {\n                    current.node.childNodes = []\n                }\n                const data = unescape(\n                    html.slice(start, html.indexOf(\"<\", start))\n                )\n                current.node.childNodes.push({\n                    nodeName: \"#text\",\n                    data,\n                })\n                if (\n                    options.valueDiffing &&\n                    current.node.nodeName === \"TEXTAREA\"\n                ) {\n                    current.node.value = data\n                }\n            }\n            // if we're at root, push new base node\n            if (level === 0 && current.node.nodeName) {\n                result.push(current.node)\n            }\n\n            const parent = arr[level - 1]\n            if (parent && current.node.nodeName) {\n                if (!parent.node.childNodes) {\n                    parent.node.childNodes = []\n                }\n                parent.node.childNodes.push(current.node)\n            }\n            arr[level] = current\n        }\n        if (!isOpen || current.voidElement) {\n            if (\n                level > -1 &&\n                (current.voidElement ||\n                    current.node.nodeName === tag.slice(2, -1).toUpperCase())\n            ) {\n                level--\n                // move current up a level to match the end tag\n                if (level > -1) {\n                    current = arr[level]\n                }\n            }\n            if (!inComponent && nextChar !== \"<\" && nextChar) {\n                // trailing text node\n                // if we're at the root, push a base text node. otherwise add as\n                // a child to the current node.\n                const childNodes =\n                    level === -1 ? result : arr[level].node.childNodes || []\n\n                // calculate correct end of the data slice in case there's\n                // no tag after the text node.\n                const end = html.indexOf(\"<\", start)\n                let data = unescape(\n                    html.slice(start, end === -1 ? undefined : end)\n                )\n                childNodes.push({\n                    nodeName: \"#text\",\n                    data,\n                })\n            }\n        }\n        return \"\"\n    })\n    return result[0]\n}\n","import {\n    DiffDOMOptions,\n    diffNodeType,\n    elementDiffNodeType,\n    elementNodeType,\n    subsetType,\n    textDiffNodeType,\n} from \"../types\"\nimport {\n    DiffTracker,\n    cleanNode,\n    getGapInformation,\n    isEqual,\n    markSubTrees,\n    removeDone,\n    roughlyEqual,\n} from \"./helpers\"\nimport { Diff } from \"../helpers\"\nimport { applyVirtual } from \"./apply\"\nimport { nodeToObj } from \"./fromDOM\"\nimport { stringToObj } from \"./fromString\"\n\n// ===== Create a diff =====\n\nexport class DiffFinder {\n    debug: boolean\n    diffcount: number\n    foundAll: boolean\n    options: DiffDOMOptions\n    t1: elementDiffNodeType\n    t1Orig: elementNodeType\n    t2: elementDiffNodeType\n    t2Orig: elementNodeType\n    tracker: DiffTracker\n    constructor(\n        t1Node: string | elementNodeType | Element,\n        t2Node: string | elementNodeType | Element,\n        options: DiffDOMOptions\n    ) {\n        this.options = options\n        this.t1 = (\n            typeof Element !== \"undefined\" && t1Node instanceof Element\n                ? nodeToObj(t1Node, this.options)\n                : typeof t1Node === \"string\"\n                ? stringToObj(t1Node, this.options)\n                : JSON.parse(JSON.stringify(t1Node))\n        ) as elementDiffNodeType\n        this.t2 = (\n            typeof Element !== \"undefined\" && t2Node instanceof Element\n                ? nodeToObj(t2Node, this.options)\n                : typeof t2Node === \"string\"\n                ? stringToObj(t2Node, this.options)\n                : JSON.parse(JSON.stringify(t2Node))\n        ) as elementDiffNodeType\n        this.diffcount = 0\n        this.foundAll = false\n        if (this.debug) {\n            this.t1Orig =\n                typeof Element !== \"undefined\" && t1Node instanceof Element\n                    ? nodeToObj(t1Node, this.options)\n                    : typeof t1Node === \"string\"\n                    ? stringToObj(t1Node, this.options)\n                    : JSON.parse(JSON.stringify(t1Node))\n            this.t2Orig =\n                typeof Element !== \"undefined\" && t2Node instanceof Element\n                    ? nodeToObj(t2Node, this.options)\n                    : typeof t2Node === \"string\"\n                    ? stringToObj(t2Node, this.options)\n                    : JSON.parse(JSON.stringify(t2Node))\n        }\n\n        this.tracker = new DiffTracker()\n    }\n\n    init() {\n        return this.findDiffs(this.t1, this.t2)\n    }\n\n    findDiffs(t1: elementDiffNodeType, t2: elementDiffNodeType) {\n        let diffs\n        do {\n            if (this.options.debug) {\n                this.diffcount += 1\n                if (this.diffcount > this.options.diffcap) {\n                    throw new Error(\n                        `surpassed diffcap:${JSON.stringify(\n                            this.t1Orig\n                        )} -> ${JSON.stringify(this.t2Orig)}`\n                    )\n                }\n            }\n            diffs = this.findNextDiff(t1, t2, [])\n\n            if (diffs.length === 0) {\n                // Last check if the elements really are the same now.\n                // If not, remove all info about being done and start over.\n                // Sometimes a node can be marked as done, but the creation of subsequent diffs means that it has to be changed again.\n                if (!isEqual(t1, t2)) {\n                    if (this.foundAll) {\n                        console.error(\"Could not find remaining diffs!\")\n                    } else {\n                        this.foundAll = true\n                        removeDone(t1)\n                        diffs = this.findNextDiff(t1, t2, [])\n                    }\n                }\n            }\n            if (diffs.length > 0) {\n                this.foundAll = false\n                this.tracker.add(diffs)\n                applyVirtual(t1, diffs, this.options)\n            }\n        } while (diffs.length > 0)\n\n        return this.tracker.list\n    }\n\n    findNextDiff(t1: diffNodeType, t2: diffNodeType, route: number[]) {\n        let diffs\n        let fdiffs\n\n        if (this.options.maxDepth && route.length > this.options.maxDepth) {\n            return []\n        }\n        // outer differences?\n        if (!t1.outerDone) {\n            diffs = this.findOuterDiff(t1, t2, route)\n            if (this.options.filterOuterDiff) {\n                fdiffs = this.options.filterOuterDiff(t1, t2, diffs)\n                if (fdiffs) diffs = fdiffs\n            }\n            if (diffs.length > 0) {\n                t1.outerDone = true\n                return diffs\n            } else {\n                t1.outerDone = true\n            }\n        }\n        if (Object.prototype.hasOwnProperty.call(t1, \"data\")) {\n            // Comment or Text\n            return []\n        }\n        t1 = t1 as elementDiffNodeType\n        t2 = t2 as elementDiffNodeType\n\n        // inner differences?\n        if (!t1.innerDone) {\n            diffs = this.findInnerDiff(t1, t2, route)\n            if (diffs.length > 0) {\n                return diffs\n            } else {\n                t1.innerDone = true\n            }\n        }\n\n        if (this.options.valueDiffing && !t1.valueDone) {\n            // value differences?\n            diffs = this.findValueDiff(t1, t2, route)\n\n            if (diffs.length > 0) {\n                t1.valueDone = true\n                return diffs\n            } else {\n                t1.valueDone = true\n            }\n        }\n\n        // no differences\n        return []\n    }\n\n    findOuterDiff(t1: diffNodeType, t2: diffNodeType, route: number[]) {\n        const diffs = []\n        let attr\n        let attr1\n        let attr2\n        let attrLength\n        let pos\n        let i\n        if (t1.nodeName !== t2.nodeName) {\n            if (!route.length) {\n                throw new Error(\"Top level nodes have to be of the same kind.\")\n            }\n            return [\n                new Diff()\n                    .setValue(\n                        this.options._const.action,\n                        this.options._const.replaceElement\n                    )\n                    .setValue(this.options._const.oldValue, cleanNode(t1))\n                    .setValue(this.options._const.newValue, cleanNode(t2))\n                    .setValue(this.options._const.route, route),\n            ]\n        }\n        if (\n            route.length &&\n            this.options.diffcap <\n                Math.abs(\n                    (t1.childNodes || []).length - (t2.childNodes || []).length\n                )\n        ) {\n            return [\n                new Diff()\n                    .setValue(\n                        this.options._const.action,\n                        this.options._const.replaceElement\n                    )\n                    .setValue(this.options._const.oldValue, cleanNode(t1))\n                    .setValue(this.options._const.newValue, cleanNode(t2))\n                    .setValue(this.options._const.route, route),\n            ]\n        }\n\n        if (\n            Object.prototype.hasOwnProperty.call(t1, \"data\") &&\n            (t1 as textDiffNodeType).data !== (t2 as textDiffNodeType).data\n        ) {\n            // Comment or text node.\n            if (t1.nodeName === \"#text\") {\n                return [\n                    new Diff()\n                        .setValue(\n                            this.options._const.action,\n                            this.options._const.modifyTextElement\n                        )\n                        .setValue(this.options._const.route, route)\n                        .setValue(\n                            this.options._const.oldValue,\n                            (t1 as textDiffNodeType).data\n                        )\n                        .setValue(\n                            this.options._const.newValue,\n                            (t2 as textDiffNodeType).data\n                        ),\n                ]\n            } else {\n                return [\n                    new Diff()\n                        .setValue(\n                            this.options._const.action,\n                            this.options._const.modifyComment\n                        )\n                        .setValue(this.options._const.route, route)\n                        .setValue(\n                            this.options._const.oldValue,\n                            (t1 as textDiffNodeType).data\n                        )\n                        .setValue(\n                            this.options._const.newValue,\n                            (t2 as textDiffNodeType).data\n                        ),\n                ]\n            }\n        }\n\n        t1 = t1 as elementDiffNodeType\n        t2 = t2 as elementDiffNodeType\n\n        attr1 = t1.attributes ? Object.keys(t1.attributes).sort() : []\n        attr2 = t2.attributes ? Object.keys(t2.attributes).sort() : []\n\n        attrLength = attr1.length\n        for (i = 0; i < attrLength; i++) {\n            attr = attr1[i]\n            pos = attr2.indexOf(attr)\n            if (pos === -1) {\n                diffs.push(\n                    new Diff()\n                        .setValue(\n                            this.options._const.action,\n                            this.options._const.removeAttribute\n                        )\n                        .setValue(this.options._const.route, route)\n                        .setValue(this.options._const.name, attr)\n                        .setValue(\n                            this.options._const.value,\n                            t1.attributes[attr]\n                        )\n                )\n            } else {\n                attr2.splice(pos, 1)\n                if (t1.attributes[attr] !== t2.attributes[attr]) {\n                    diffs.push(\n                        new Diff()\n                            .setValue(\n                                this.options._const.action,\n                                this.options._const.modifyAttribute\n                            )\n                            .setValue(this.options._const.route, route)\n                            .setValue(this.options._const.name, attr)\n                            .setValue(\n                                this.options._const.oldValue,\n                                t1.attributes[attr]\n                            )\n                            .setValue(\n                                this.options._const.newValue,\n                                t2.attributes[attr]\n                            )\n                    )\n                }\n            }\n        }\n\n        attrLength = attr2.length\n        for (i = 0; i < attrLength; i++) {\n            attr = attr2[i]\n            diffs.push(\n                new Diff()\n                    .setValue(\n                        this.options._const.action,\n                        this.options._const.addAttribute\n                    )\n                    .setValue(this.options._const.route, route)\n                    .setValue(this.options._const.name, attr)\n                    .setValue(this.options._const.value, t2.attributes[attr])\n            )\n        }\n\n        return diffs\n    }\n\n    findInnerDiff(\n        t1: elementDiffNodeType,\n        t2: elementDiffNodeType,\n        route: number[]\n    ) {\n        const t1ChildNodes = t1.childNodes ? t1.childNodes.slice() : []\n        const t2ChildNodes = t2.childNodes ? t2.childNodes.slice() : []\n        const last = Math.max(t1ChildNodes.length, t2ChildNodes.length)\n        let childNodesLengthDifference = Math.abs(\n            t1ChildNodes.length - t2ChildNodes.length\n        )\n        let diffs: Diff[] = []\n        let index = 0\n        if (!this.options.maxChildCount || last < this.options.maxChildCount) {\n            const cachedSubtrees = Boolean(t1.subsets && t1.subsetsAge--)\n            const subtrees = cachedSubtrees\n                ? t1.subsets\n                : t1.childNodes && t2.childNodes\n                ? markSubTrees(t1, t2)\n                : []\n            if (subtrees.length > 0) {\n                /* One or more groups have been identified among the childnodes of t1\n                 * and t2.\n                 */\n                diffs = this.attemptGroupRelocation(\n                    t1,\n                    t2,\n                    subtrees,\n                    route,\n                    cachedSubtrees\n                )\n                if (diffs.length > 0) {\n                    return diffs\n                }\n            }\n        }\n\n        /* 0 or 1 groups of similar child nodes have been found\n         * for t1 and t2. 1 If there is 1, it could be a sign that the\n         * contents are the same. When the number of groups is below 2,\n         * t1 and t2 are made to have the same length and each of the\n         * pairs of child nodes are diffed.\n         */\n\n        for (let i = 0; i < last; i += 1) {\n            const e1 = t1ChildNodes[i]\n            const e2 = t2ChildNodes[i]\n\n            if (childNodesLengthDifference) {\n                /* t1 and t2 have different amounts of childNodes. Add\n                 * and remove as necessary to obtain the same length */\n                if (e1 && !e2) {\n                    if (e1.nodeName === \"#text\") {\n                        diffs.push(\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.removeTextElement\n                                )\n                                .setValue(\n                                    this.options._const.route,\n                                    route.concat(index)\n                                )\n                                .setValue(\n                                    this.options._const.value,\n                                    (e1 as textDiffNodeType).data\n                                )\n                        )\n                        index -= 1\n                    } else {\n        //                console.log(1)\n                        diffs.push(\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.removeElement\n                                )\n                                .setValue(\n                                    this.options._const.route,\n                                    route.concat(index)\n                                )\n                                .setValue(\n                                    this.options._const.element,\n                                    cleanNode(e1)\n                                )\n                        )\n                        index -= 1\n                    }\n                } else if (e2 && !e1) {\n                    if (e2.nodeName === \"#text\") {\n                        diffs.push(\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.addTextElement\n                                )\n                                .setValue(\n                                    this.options._const.route,\n                                    route.concat(index)\n                                )\n                                .setValue(\n                                    this.options._const.value,\n                                    (e2 as textDiffNodeType).data\n                                )\n                        )\n                    } else {\n                        diffs.push(\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.addElement\n                                )\n                                .setValue(\n                                    this.options._const.route,\n                                    route.concat(index)\n                                )\n                                .setValue(\n                                    this.options._const.element,\n                                    cleanNode(e2)\n                                )\n                        )\n                    }\n                }\n            }\n            /* We are now guaranteed that childNodes e1 and e2 exist,\n             * and that they can be diffed.\n             */\n            /* Diffs in child nodes should not affect the parent node,\n             * so we let these diffs be submitted together with other\n             * diffs.\n             */\n\n            if (e1 && e2) {\n                if (\n                    !this.options.maxChildCount ||\n                    last < this.options.maxChildCount\n                ) {\n                    diffs = diffs.concat(\n                        this.findNextDiff(e1, e2, route.concat(index))\n                    )\n                } else if (!isEqual(e1, e2)) {\n                    if (t1ChildNodes.length > t2ChildNodes.length) {\n                        if (e1.nodeName === \"#text\") {\n                            diffs.push(\n                                new Diff()\n                                    .setValue(\n                                        this.options._const.action,\n                                        this.options._const.removeTextElement\n                                    )\n                                    .setValue(\n                                        this.options._const.route,\n                                        route.concat(index)\n                                    )\n                                    .setValue(\n                                        this.options._const.value,\n                                        (e1 as textDiffNodeType).data\n                                    )\n                            )\n                        } else {\n        //                    console.log(2)\n                            diffs.push(\n                                new Diff()\n                                    .setValue(\n                                        this.options._const.action,\n                                        this.options._const.removeElement\n                                    )\n                                    .setValue(\n                                        this.options._const.element,\n                                        cleanNode(e1)\n                                    )\n                                    .setValue(\n                                        this.options._const.route,\n                                        route.concat(index)\n                                    )\n                            )\n                        }\n                        t1ChildNodes.splice(i, 1)\n                        i -= 1\n                        index -= 1\n\n                        childNodesLengthDifference -= 1\n                    } else if (t1ChildNodes.length < t2ChildNodes.length) {\n                        const cloneChild = cleanNode(e2)\n                        diffs = diffs.concat([\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.addElement\n                                )\n                                .setValue(\n                                    this.options._const.element,\n                                    cloneChild\n                                )\n                                .setValue(\n                                    this.options._const.route,\n                                    route.concat(index)\n                                ),\n                        ])\n                        t1ChildNodes.splice(i, 0, cloneChild)\n                        childNodesLengthDifference -= 1\n                    } else {\n                        diffs = diffs.concat([\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.replaceElement\n                                )\n                                .setValue(\n                                    this.options._const.oldValue,\n                                    cleanNode(e1)\n                                )\n                                .setValue(\n                                    this.options._const.newValue,\n                                    cleanNode(e2)\n                                )\n                                .setValue(\n                                    this.options._const.route,\n                                    route.concat(index)\n                                ),\n                        ])\n                    }\n                }\n            }\n            index += 1\n        }\n        t1.innerDone = true\n        return diffs\n    }\n\n    attemptGroupRelocation(\n        t1: elementDiffNodeType,\n        t2: elementDiffNodeType,\n        subtrees: subsetType[],\n        route: number[],\n        cachedSubtrees: boolean\n    ) {\n        /* Either t1.childNodes and t2.childNodes have the same length, or\n         * there are at least two groups of similar elements can be found.\n         * attempts are made at equalizing t1 with t2. First all initial\n         * elements with no group affiliation (gaps=true) are removed (if\n         * only in t1) or added (if only in t2). Then the creation of a group\n         * relocation diff is attempted.\n         */\n        const gapInformation = getGapInformation(t1, t2, subtrees)\n        const gaps1 = gapInformation.gaps1\n        const gaps2 = gapInformation.gaps2\n        let shortest = Math.min(gaps1.length, gaps2.length)\n        let destinationDifferent\n        let toGroup\n        let group\n        let node\n        let similarNode\n        let testI\n        const diffs = []\n        console.log({gaps1: gaps1.slice(), gaps2: gaps2.slice(), shortest})\n        for (\n            let index2 = 0, index1 = 0;\n            index2 < shortest;\n            index1 += 1, index2 += 1\n        ) {\n        //    console.log({index1, index2})\n            if (\n                cachedSubtrees &&\n                (gaps1[index2] === true || gaps2[index2] === true)\n            ) {\n                // pass\n            } else if (gaps1[index2] === true) {\n                node = t1.childNodes[index1]\n                if (node.nodeName === \"#text\") {\n                    if (t2.childNodes[index2].nodeName === \"#text\") {\n                        if (\n                            (node as textDiffNodeType).data !==\n                            (t2.childNodes[index2] as textDiffNodeType).data\n                        ) {\n                            testI = index1\n                            while (\n                                t1.childNodes.length > testI + 1 &&\n                                t1.childNodes[testI + 1].nodeName === \"#text\"\n                            ) {\n                                testI += 1\n                                if (\n                                    (t2.childNodes[index2] as textDiffNodeType)\n                                        .data ===\n                                    (t1.childNodes[testI] as textDiffNodeType)\n                                        .data\n                                ) {\n                                    similarNode = true\n                                    break\n                                }\n                            }\n                            if (!similarNode) {\n                                diffs.push(\n                                    new Diff()\n                                        .setValue(\n                                            this.options._const.action,\n                                            this.options._const\n                                                .modifyTextElement\n                                        )\n                                        .setValue(\n                                            this.options._const.route,\n                                            route.concat(index2)\n                                        )\n                                        .setValue(\n                                            this.options._const.oldValue,\n                                            node.data\n                                        )\n                                        .setValue(\n                                            this.options._const.newValue,\n                                            (\n                                                t2.childNodes[\n                                                    index2\n                                                ] as textDiffNodeType\n                                            ).data\n                                        )\n                                )\n                                return diffs\n                            }\n                        }\n                    } else {\n                        diffs.push(\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.removeTextElement\n                                )\n                                .setValue(\n                                    this.options._const.route,\n                                    route.concat(index2)\n                                )\n                                .setValue(this.options._const.value, node.data)\n                        )\n                        gaps1.splice(index2, 1)\n                        shortest = Math.min(gaps1.length, gaps2.length)\n                        index2 -= 1\n                    }\n                } else if (!roughlyEqual(\n                    t1.childNodes[index1],\n                    t2.childNodes[index2],\n                    {},\n                    false,\n                    true\n                )) {\n                //    console.log(3)\n                    diffs.push(\n                        new Diff()\n                            .setValue(\n                                this.options._const.action,\n                                this.options._const.removeElement\n                            )\n                            .setValue(\n                                this.options._const.route,\n                                route.concat(index2)\n                            )\n                            .setValue(\n                                this.options._const.element,\n                                cleanNode(node)\n                            )\n                    )\n                    gaps1.splice(index2, 1)\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    index2 -= 1\n                }\n            } else if (gaps2[index2] === true) {\n                node = t2.childNodes[index2]\n                if (node.nodeName === \"#text\") {\n                    diffs.push(\n                        new Diff()\n                            .setValue(\n                                this.options._const.action,\n                                this.options._const.addTextElement\n                            )\n                            .setValue(\n                                this.options._const.route,\n                                route.concat(index2)\n                            )\n                            .setValue(this.options._const.value, node.data)\n                    )\n                    gaps1.splice(index2, 0, true)\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    index1 -= 1\n                } else {\n                    diffs.push(\n                        new Diff()\n                            .setValue(\n                                this.options._const.action,\n                                this.options._const.addElement\n                            )\n                            .setValue(\n                                this.options._const.route,\n                                route.concat(index2)\n                            )\n                            .setValue(\n                                this.options._const.element,\n                                cleanNode(node)\n                            )\n                    )\n                    gaps1.splice(index2, 0, true)\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    index1 -= 1\n                }\n            } else if (gaps1[index2] !== gaps2[index2]) {\n                if (diffs.length > 0) {\n                    return diffs\n                }\n                // group relocation\n                group = subtrees[gaps1[index2] as number]\n                toGroup = Math.min(\n                    group.newValue,\n                    t1.childNodes.length - group.length\n                )\n                if (toGroup !== group.oldValue) {\n                    // Check whether destination nodes are different than originating ones.\n                    destinationDifferent = false\n                    for (let j = 0; j < group.length; j += 1) {\n                        if (\n                            !roughlyEqual(\n                                t1.childNodes[toGroup + j],\n                                t1.childNodes[group.oldValue + j],\n                                {},\n                                false,\n                                true\n                            )\n                        ) {\n                            destinationDifferent = true\n                        }\n                    }\n                    if (destinationDifferent) {\n                        return [\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.relocateGroup\n                                )\n                                .setValue(\n                                    this.options._const.groupLength,\n                                    group.length\n                                )\n                                .setValue(\n                                    this.options._const.from,\n                                    group.oldValue\n                                )\n                                .setValue(this.options._const.to, toGroup)\n                                .setValue(this.options._const.route, route),\n                        ]\n                    }\n                }\n            }\n        }\n        return diffs\n    }\n\n    findValueDiff(\n        t1: elementDiffNodeType,\n        t2: elementDiffNodeType,\n        route: number[]\n    ) {\n        // Differences of value. Only useful if the value/selection/checked value\n        // differs from what is represented in the DOM. For example in the case\n        // of filled out forms, etc.\n        const diffs = []\n\n        if (t1.selected !== t2.selected) {\n            diffs.push(\n                new Diff()\n                    .setValue(\n                        this.options._const.action,\n                        this.options._const.modifySelected\n                    )\n                    .setValue(this.options._const.oldValue, t1.selected)\n                    .setValue(this.options._const.newValue, t2.selected)\n                    .setValue(this.options._const.route, route)\n            )\n        }\n\n        if (\n            (t1.value || t2.value) &&\n            t1.value !== t2.value &&\n            t1.nodeName !== \"OPTION\"\n        ) {\n            diffs.push(\n                new Diff()\n                    .setValue(\n                        this.options._const.action,\n                        this.options._const.modifyValue\n                    )\n                    .setValue(this.options._const.oldValue, t1.value || \"\")\n                    .setValue(this.options._const.newValue, t2.value || \"\")\n                    .setValue(this.options._const.route, route)\n            )\n        }\n        if (t1.checked !== t2.checked) {\n            diffs.push(\n                new Diff()\n                    .setValue(\n                        this.options._const.action,\n                        this.options._const.modifyChecked\n                    )\n                    .setValue(this.options._const.oldValue, t1.checked)\n                    .setValue(this.options._const.newValue, t2.checked)\n                    .setValue(this.options._const.route, route)\n            )\n        }\n\n        return diffs\n    }\n}\n","import {\n    ConstNames,\n    ConstNamesPartial,\n    DiffDOMOptions,\n    DiffDOMOptionsPartial,\n    diffType,\n    elementNodeType,\n    textNodeType,\n} from \"./types\"\nimport { applyDOM, undoDOM } from \"./dom/index\"\nimport { Diff } from \"./helpers\"\nimport { DiffFinder } from \"./virtual/index\"\nexport { nodeToObj, stringToObj } from \"./virtual/index\"\n\nconst DEFAULT_OPTIONS = {\n    debug: false,\n    diffcap: 10, // Limit for how many diffs are accepting when debugging. Inactive when debug is false.\n    maxDepth: false, // False or a numeral. If set to a numeral, limits the level of depth that the the diff mechanism looks for differences. If false, goes through the entire tree.\n    maxChildCount: 50, // False or a numeral. If set to a numeral, only does a simplified form of diffing of contents so that the number of diffs cannot be higher than the number of child nodes.\n    valueDiffing: true, // Whether to take into consideration the values of forms that differ from auto assigned values (when a user fills out a form).\n    // syntax: textDiff: function (node, currentValue, expectedValue, newValue)\n    textDiff(\n        node: textNodeType,\n        currentValue: string,\n        expectedValue: string,\n        newValue: string\n    ) {\n        node.data = newValue\n        return\n    },\n    // empty functions were benchmarked as running faster than both\n    // `f && f()` and `if (f) { f(); }`\n    preVirtualDiffApply() {}, // eslint-disable-line @typescript-eslint/no-empty-function\n    postVirtualDiffApply() {}, // eslint-disable-line @typescript-eslint/no-empty-function\n    preDiffApply() {}, // eslint-disable-line @typescript-eslint/no-empty-function\n    postDiffApply() {}, // eslint-disable-line @typescript-eslint/no-empty-function\n    filterOuterDiff: null,\n    compress: false, // Whether to work with compressed diffs\n    _const: false, // object with strings for every change types to be used in diffs.\n    document:\n        typeof window !== \"undefined\" && window.document\n            ? window.document\n            : false,\n    components: [], // list of components used for converting from string\n}\n\nexport class DiffDOM {\n    options: DiffDOMOptions\n    constructor(options: DiffDOMOptionsPartial = {}) {\n        // IE11 doesn't have Object.assign and buble doesn't translate object spreaders\n        // by default, so this is the safest way of doing it currently.\n        Object.entries(DEFAULT_OPTIONS).forEach(([key, value]) => {\n            if (!Object.prototype.hasOwnProperty.call(options, key)) {\n                options[key] = value\n            }\n        })\n\n        if (!options._const) {\n            const varNames = [\n                \"addAttribute\",\n                \"modifyAttribute\",\n                \"removeAttribute\",\n                \"modifyTextElement\",\n                \"relocateGroup\",\n                \"removeElement\",\n                \"addElement\",\n                \"removeTextElement\",\n                \"addTextElement\",\n                \"replaceElement\",\n                \"modifyValue\",\n                \"modifyChecked\",\n                \"modifySelected\",\n                \"modifyComment\",\n                \"action\",\n                \"route\",\n                \"oldValue\",\n                \"newValue\",\n                \"element\",\n                \"group\",\n                \"groupLength\",\n                \"from\",\n                \"to\",\n                \"name\",\n                \"value\",\n                \"data\",\n                \"attributes\",\n                \"nodeName\",\n                \"childNodes\",\n                \"checked\",\n                \"selected\",\n            ]\n            const constNames: ConstNamesPartial = {}\n            if (options.compress) {\n                varNames.forEach(\n                    (varName, index) => (constNames[varName] = index)\n                )\n            } else {\n                varNames.forEach((varName) => (constNames[varName] = varName))\n            }\n            options._const = constNames as ConstNames\n        }\n\n        this.options = options as DiffDOMOptions\n    }\n\n    apply(tree: Element, diffs: (Diff | diffType)[]) {\n        return applyDOM(tree, diffs, this.options)\n    }\n\n    undo(tree: Element, diffs: (Diff | diffType)[]) {\n        return undoDOM(tree, diffs, this.options)\n    }\n\n    diff(\n        t1Node: string | elementNodeType | Element,\n        t2Node: string | elementNodeType | Element\n    ) {\n        const finder = new DiffFinder(t1Node, t2Node, this.options)\n        return finder.init()\n    }\n}\n","/**\n * Use TraceLogger to figure out function calls inside\n * JS objects by wrapping an object with a TraceLogger\n * instance.\n *\n * Pretty-prints the call trace (using unicode box code)\n * when tracelogger.toString() is called.\n */\n\n/**\n * Wrap an object by calling new TraceLogger(obj)\n *\n * If you're familiar with Python decorators, this\n * does roughly the same thing, adding pre/post\n * call hook logging calls so that you can see\n * what's going on.\n */\nexport class TraceLogger {\n    messages: string[]\n    pad: string\n    padding: string\n    tick: number\n    constructor(obj = {}) {\n        this.pad = \"│   \"\n        this.padding = \"\"\n        this.tick = 1\n        this.messages = []\n        const wrapkey = (obj: object, key: string) => {\n            // trace this function\n            const oldfn = obj[key]\n            obj[key] = (\n                ...args: ((\n                    ...args: (\n                        | string\n                        | HTMLElement\n                        | number\n                        | boolean\n                        | false\n                        | (string | HTMLElement | number | boolean | false)[]\n                    )[]\n                ) => void)[]\n            ) => {\n                this.fin(key, Array.prototype.slice.call(args))\n                const result = oldfn.apply(obj, args)\n                this.fout(key, result)\n                return result\n            }\n        }\n        // can't use Object.keys for prototype walking\n        for (let key in obj) {\n            if (typeof obj[key] === \"function\") {\n                wrapkey(obj, key)\n            }\n        }\n        this.log(\"┌ TRACELOG START\")\n    }\n    // called when entering a function\n    fin(\n        fn: string,\n        args:\n            | string\n            | HTMLElement\n            | number\n            | boolean\n            | false\n            | (string | HTMLElement | number | boolean | false)[]\n    ) {\n        this.padding += this.pad\n        this.log(`├─> entering ${fn}`, args)\n    }\n    // called when exiting a function\n    fout(\n        fn: string,\n        result:\n            | string\n            | HTMLElement\n            | number\n            | boolean\n            | false\n            | (string | HTMLElement | number | boolean | false)[]\n    ) {\n        this.log(\"│<──┘ generated return value\", result)\n        this.padding = this.padding.substring(\n            0,\n            this.padding.length - this.pad.length\n        )\n    }\n    // log message formatting\n    format(s: string, tick: number) {\n        let nf = function (t: number) {\n            let tStr = `${t}`\n            while (tStr.length < 4) {\n                tStr = `0${t}`\n            }\n            return tStr\n        }\n        return `${nf(tick)}> ${this.padding}${s}`\n    }\n    // log a trace message\n    log(...args) {\n        const stringCollapse = function (\n            v:\n                | string\n                | HTMLElement\n                | number\n                | boolean\n                | false\n                | (string | HTMLElement | number | boolean | false)[]\n        ) {\n            if (!v) {\n                return \"<falsey>\"\n            }\n            if (typeof v === \"string\") {\n                return v\n            }\n            if (v instanceof HTMLElement) {\n                return v.outerHTML || \"<empty>\"\n            }\n            if (v instanceof Array) {\n                return `[${v.map(stringCollapse).join(\",\")}]`\n            }\n            return v.toString() || v.valueOf() || \"<unknown>\"\n        }\n        const s = args.map(stringCollapse).join(\", \")\n        this.messages.push(this.format(s, this.tick++))\n    }\n    // turn the log into a structured string with\n    // unicode box codes to make it a sensible trace.\n    toString() {\n        let cap = \"×   \"\n        let terminator = \"└───\"\n        while (terminator.length <= this.padding.length + this.pad.length) {\n            terminator += cap\n        }\n        let _ = this.padding\n        this.padding = \"\"\n        terminator = this.format(terminator, this.tick)\n        this.padding = _\n        return `${this.messages.join(\"\\n\")}\\n${terminator}`\n    }\n}\n"],"names":["objToNode","objNode","insideSvg","options","node","nodeName","document","createTextNode","data","createComment","createElementNS","toLowerCase","createElement","attributes","Object","entries","forEach","_a","key","value","setAttribute","childNodes","childNode","appendChild","valueDiffing","HTMLButtonElement","HTMLDataElement","HTMLInputElement","HTMLLIElement","HTMLMeterElement","HTMLOptionElement","HTMLProgressElement","HTMLParamElement","checked","selected","getFromRoute","route","slice","length","c","splice","applyDiff","tree","diff","newNode","reference","action","_const","addElement","addTextElement","includes","info","preDiffApply","addAttribute","Element","name","modifyAttribute","newValue","removeAttribute","modifyTextElement","Text","textDiff","oldValue","parentNode","HTMLTextAreaElement","modifyValue","modifyComment","Comment","modifyChecked","modifySelected","replaceElement","namespaceURI","replaceChild","relocateGroup","Array","apply","groupLength","map","removeChild","from","index","to","insertBefore","removeElement","parentRoute","element","removeTextElement","nodeType","console","log","postDiffApply","swap","obj","p1","p2","tmp","undoDOM","diffs","reverse","undoDiff","elementDescriptors","el","output","push","concat","replace","id","findUniqueDescriptors","li","uniqueDescriptors","duplicateDescriptors","descriptor","inUnique","uniqueInBoth","l1","l2","l1Unique","l2Unique","inBoth","keys","removeDone","outerDone","innerDone","valueDone","every","cleanNode","diffNode","prototype","hasOwnProperty","call","elementNode","diffChildNode","isEqual","e1","e2","Boolean","e1Attributes","e2Attributes","attribute","roughlyEqual","sameSiblings","preventRecursion","similarity","nodeList1","nodeList2","childUniqueDescriptors_1","reduce","a","b","Math","max","min","makeBooleanArray","n","v","markSubTrees","oldTree","newTree","oldChildren","newChildren","marked1","marked2","subsets","returnIndex","arguments","foundAllSubsets","subset","c1","c2","lcsSize","lcsSimilarity","c1Length","c2Length","matches","subsetsSame","some","i","c1Desc","c2Desc","description","c1Index","c1Element","c2Index","c2Element","elementSimilarity","findCommonSubsets","item","markBoth","subsetsAge","DiffTracker","this","list","add","fn","Diff","_this","toString","JSON","stringify","setValue","aKey","aValue","getFromVirtualRoute","nodeIndex","undefined","applyVirtual","routeInfo","newSubsets","preVirtualDiffApply","movedNode","splitLength","c_1","c_2","filter","postVirtualDiffApply","applyVirtualDiff","nodeToObj","aNode","type","tagRE","attrRE","unescape","string","lookup","area","base","br","col","embed","hr","img","input","keygen","link","menuItem","meta","param","source","track","wbr","parseTag","tag","res","voidElement","tagMatch","match","toUpperCase","charAt","startsWith","endIndex","indexOf","reg","RegExp","result","done","exec","trim","attr","arr","split","lastIndex","substring","stringToObj","html","current","level","end","isOpen","isComment","start","nextChar","comment","parent_1","parent_2","DiffFinder","t1Node","t2Node","t1","parse","t2","diffcount","foundAll","debug","t1Orig","t2Orig","tracker","init","findDiffs","diffcap","Error","findNextDiff","error","fdiffs","maxDepth","findOuterDiff","filterOuterDiff","findInnerDiff","findValueDiff","attr1","attr2","attrLength","pos","abs","sort","t1ChildNodes","t2ChildNodes","last","childNodesLengthDifference","maxChildCount","cachedSubtrees","subtrees","attemptGroupRelocation","cloneChild","destinationDifferent","toGroup","group","similarNode","testI","gapInformation","stable","gaps1","gaps2","endOld","endNew","j","getGapInformation","shortest","index2","index1","DEFAULT_OPTIONS","currentValue","expectedValue","compress","window","components","DiffDOM","varNames","constNames_1","varName","applyDOM","undo","TraceLogger","pad","padding","tick","messages","wrapkey","oldfn","args","_i","fin","fout","format","s","t","tStr","nf","stringCollapse","HTMLElement","outerHTML","join","valueOf","terminator","_"],"mappings":"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"}